#Description: 15 Puzzle
#Start Date: 15 FEB 2016
#End Date: 4 MAR 2016
#Author: Andrii Grytsenko
#Programing Language: Python (on-line interpreter www.codeskulptor.org)

1 Classes hierarchy

                        |<- Draught
Block <- VisualBlock <- |
                        |<- Draughts

1.1 class Block
Block is a very simple class. It represents some "abstract" (it means invisible) rectangle block.
It has a size (width and height) and a position (x and y coordinates).

Class Block can do in public:
- get/set its position in three different ways:
-- get/set X coordinate
-- get/set Y coordinate
-- get/set list of coordinates [x, y]
- get/set its size in three different ways:
-- get/set width (length by X coordinate)
-- get/set height (length by Y coordinate)
-- get/set width and height togather as a list
- get its top left coordanate as a list [x, y]
- get its top right coordanate as a list [x, y]
- get its bottom left coordanate as a list [x, y]
- get its bottom right coordanate as a list [x, y]
- get its coordanates as a list [TL_coord, TR_coord, BR_coord, BL_coord]

1.2 class VisualBlock
Class VisualBlock inherits from class Block and provides functionality to visualize a Block.
Class has extra private fields:
- color (block and border)
- width of its border

Access to these private fields can be provided by public methods:
- get/set color of block itself
- get/set color of its border
- get/set color as a list [blockColor, borderColor]
- get width of border: border is designed as a read-only field

Class can contains other instances of VisualBlock class and stores they in a list (items).
Method append is used to add items to the list.
Class can draw itself and all contained VisualBlock objects.
Class also can interact with user: method isSelected returns TRUE in case user clicks within object's rectangle, and FALSE otherwise.

1.3 class Draught
Class inherits from VisualBlock class and provide behaivor of one draught.
Draught has a text caption and a number ID. 
Class has a private field to store a pointer to the frame context. It is used for internal calculations in method getCaptionPosition.

Class has a set of getters and setters:
- get/set caption
- get/set number ID

In order to place caption at the center of draught class has a special method getCaptionPosition.
Method draw of the class extends inherited method of VisualBlock and add drawing a caption.

2 Game implementation (class Draughts)

2.1 Public part
Class Draughts inherits from VisualBlock class.
It acceps next parameters for constructor:
- size (inherit from VisualBlock; extended by third integer - the height of additional information panel under the main game field)
- color (inherit from VisualBlock)
- frame (pointer to the frame context)
- empty_number (tells to class which number will be tritted as an empty field)
- draughts_mtrx (a list of two integers: number of collumns and number of rows in which class will organize draughts)

Three event handlers:
- onDraw - draw game field, draughts and information panel. Method is assigned in call frame.set_draw_handler()
- onMouseClick - implements behaivor for mouse events. Method is assigned in call frame.set_mouseclick_handler()
- onReset - implements restart of current game session. Method is assigned i call frame.add_button()

2.2 Private part

2.2.1 Private fields

class Draughts(VisualBlock):
    def __init__(self, size, color, frame, empty_number, draughts_mtrx):
        VisualBlock.__init__(self, [size[0], size[1]+size[2]], [0, 0], color, 1)
        self.STR_IN_GAME = "Steps: "
        self.STR_OUT_OF_GAME = "Game over"
        self.frame = frame
        self.EMPTY_NUMBER = empty_number
        self.draughts_mtrx = list(draughts_mtrx)
        self.draught_size = [self.size[0]/self.draughts_mtrx[0], (self.size[1]-size[2])/self.draughts_mtrx[1]]
        self.fpc = FifteenPuzzleCore(draughts_mtrx[0], empty_number)
        self.fpc.shuffle()
        i = 0
        for place in self.fpc.getPlaces():
            self.append(Draught(self.draught_size, self.getDraughtPosByID(i), self.getDraughtColorByNumber(place), 
                                1, self.getDraughtCaptionByNumber(place), i, self.frame))
            i += 1
        self.infoPanel = VisualBlock([size[0], size[2]], [0, size[1]], self.getDraughtColorByNumber(self.EMPTY_NUMBER+1), 1)
        self.infoPanel.append(Draught([size[0], size[2]], [0, size[1]], self.getDraughtColorByNumber(self.EMPTY_NUMBER+1), 1, 
                                      self.STR_IN_GAME+str(self.fpc.iMovements), -1, self.frame))
        
    def getDraughtPosByID(self, ID):
        return [self.pos[0]+(self.draught_size[0]*(ID%self.draughts_mtrx[0])), 
                self.pos[1]+(self.draught_size[1]*(ID/self.draughts_mtrx[0]))]
    
    def getDraughtCaptionByNumber(self, number):
        if (number == self.EMPTY_NUMBER): return ""
        else: return str(number+1)
        
    def getDraughtColorByNumber(self, number):
        if (number == self.EMPTY_NUMBER): return list(self.color)
        else: return [self.color[1], self.color[0]]

    def getDraughtID(self, row, col): return (row*self.draughts_mtrx[0] + col)
    
    def updateDraughts(self):
        for i in range(self.draughts_mtrx[0]*self.draughts_mtrx[1]):
            self.items[i].setCaption(self.getDraughtCaptionByNumber(self.fpc.lstPlaces[i]))
            self.items[i].setColor(self.getDraughtColorByNumber(self.fpc.lstPlaces[i]))
    
    def getSelectedDraughtID(self, pos):
        found = False
        for item in self.items:
            if (not found):
                if item.isSelected(pos):
                    return item.getNumber()
        return -1
    
    def isOrdered(self): return self.fpc.isOrdered()
    
    def isMovable(self, position): return self.fpc.isMovable(self.getSelectedDraughtID(position))
    
    def moveDraught(self, position): self.fpc.moveDraught(self.getSelectedDraughtID(position))
    
    def onDraw(self, canvas):
        VisualBlock.draw(self, canvas)
        self.infoPanel.draw(canvas)
        
    def onMouseClick(self, position):
        if (not self.isOrdered()):
            if (self.isMovable(position)):
                self.moveDraught(position)
                self.updateDraughts()
                if (not self.isOrdered()):
                    self.infoPanel.items[0].setCaption(self.STR_IN_GAME+str(self.fpc.iMovements))
                else:
                    self.infoPanel.items[0].setCaption(self.STR_OUT_OF_GAME)
                
    def onReset(self):
        self.fpc.shuffle()
        self.updateDraughts()
        self.infoPanel.items[0].setCaption(self.STR_IN_GAME+str(self.fpc.iMovements))
